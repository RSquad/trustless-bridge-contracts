#include "stdlib.fc";
#include "tvm.lib.fc";
#include "errors.lib.fc";
#include "hashmap.lib.fc";

(cell, int) merkle_proof::load_cell(cell c) impure inline {
  (slice proof_slice, int exotic?) = c.begin_parse_special();
  throw_unless(err::invalid_merkle_proof_cell, exotic?);
  throw_unless(err::invalid_merkle_proof_cell, proof_slice~load_uint(8) == 3);
  cell pruned_cell = proof_slice~load_ref();
  return (pruned_cell, pruned_cell.cell_hash_0());
}

cell merkle_proof::find_tx(
  cell merkle_proof,
  slice account_addr,
  slice tx_lt
) impure inline {
  (cell ref_cell, int ref_hash) = merkle_proof.merkle_proof::load_cell();
  slice block = ref_cell.begin_parse();
  int tag = block~load_uint(32);
  throw_unless(err::invalid_block_tag, tag == 0x11ef55aa);
  ;; skip info, value_flow, and state_update
  block~load_ref();
  block~load_ref();
  block~load_ref();
  ;; load ref with extra
  slice extra = block~load_ref_slice();
  ;; skip in_msg_descr, out_msg_descr
  extra~load_ref();
  extra~load_ref();
  ;; load account_blocks
  slice s = extra~load_ref_slice();
  cell account_blocks = s~load_dict();
  ;; assume there is only one account - all others are pruned
  (slice acc_block, int ok?) = account_blocks.hm_get?(256, account_addr);
  throw_unless(err::no_accounts, ok?);
  ;; skip CurrencyCollection
  acc_block~load_coins();
  acc_block~load_dict();
  throw_unless(err::invalid_account_block, acc_block~load_uint(4) == 5);
  acc_block~load_uint(256);
  cell transactions = begin_cell().store_slice(acc_block).end_cell();
  (slice value, int ok?) = transactions.hm_get?(64, tx_lt);
  throw_unless(err::no_txs, ok?);
  value~load_coins();
  value~load_dict();
  cell tx = value~load_ref();
  return tx;
}
