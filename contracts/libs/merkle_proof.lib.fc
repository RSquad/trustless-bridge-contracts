#include "stdlib.fc";
#include "tvm.lib.fc";
#include "errors.lib.fc";

cell merkle_proof::find_tx(cell merkle_proof) impure inline {
  slice ps = merkle_proof.begin_parse();
  ~strdump("merkle_proof::find_tx");
  int tag = ps~load_uint(32);
  throw_unless(err::invalid_block_tag, tag == 0x11ef55aa);
  ;; skip info, value_flow, and state_update
  ps~load_ref();
  ps~load_ref();
  ps~load_ref();
  ;; load ref with extra
  slice extra = ps~load_ref_slice();
  ;; skip in_msg_descr, out_msg_descr
  ps~load_ref();
  ps~load_ref();
  ;; load account_blocks
  slice ps = ps~load_ref_slice();
  cell account_blocks = ps~load_dict();
  ;; assume there is only one account - all others are pruned
  (int addr, slice acc_block, int ok?) = account_blocks.idict_get_max?(256);
  throw_unless(err::no_accounts, ok?);
  acc_block~skip_bits(256);
  cell transactions = acc_block~load_dict();
  (_, cell tx, int ok?) = transactions.idict_get_max_ref?(64);
  throw_unless(err::no_txs, ok?);
  
  return tx;
}