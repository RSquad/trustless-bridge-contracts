#include "../imports/stdlib.fc";
#include "opcodes.fc";
#include "errors.fc";
#include "storage.fc";
#include "../imports/ton_msg.lib.fc";
#include "utils.fc";

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
  if ( in_msg_body.slice_empty?() ) { ;; accept simple transfer
    return ();
  }
  slice cs = in_msg_full.begin_parse();
  int flags = cs~load_uint(4);
  if ( flags & 1 ) { ;; ignore all bounced messages
    return ();
  }

  slice sender_address = cs~load_msg_addr();
  int op = in_msg_body~load_uint(32);
  int query_id = in_msg_body~load_uint(64);

  if ( op == op::new_key_block ) {
    ;; (slice cs, int special) = block.begin_parse_special();
    ;; cell test = cs~load_ref();
    cell block = in_msg_body~load_ref();
    cell signatures_c = in_msg_body~load_ref();
    int file_hash = in_msg_body~load_uint(256);
    int root_hash = cell_hash(block);

    ;; also checks if the block is keyblock
    slice custom_s = load_block_custom(block);

    slice signature_message = build_signature_message(root_hash, file_hash);
    load_globals();
    int is_block_signed = check_block_signature(signature_message, signatures_c);
    throw_unless(is_block_signed, err::unsigned_block);

    (cell validators_list, int main) = load_validators_list(custom_s);
    update_validators_dict(validators_list, main);
  
    cell msg = build_message(
      sender_address,
      0,
      false,
      null(),
      begin_cell()
        .store_uint(op::new_key_block::success, 32)
        .store_uint(query_id, 64)
        .store_uint(root_hash, 256)
        .store_slice(in_msg_body)
      .end_cell()
    ).end_cell();
    send_raw_message(msg, send_mode::carry_remaining_value);
    return ();
  }

  if ( op == op::check_block ) {
    cell block = in_msg_body~load_ref();
    cell signatures_c = in_msg_body~load_ref();
    int file_hash = in_msg_body~load_uint(256);
    int root_hash = cell_hash(block);

    slice cs = block.begin_parse();
    check_is_masterchain_block(cs~load_ref());
    slice signature_message = build_signature_message(root_hash, file_hash);
    load_globals();

    ;; if sign is correct, block in current epoch
    int is_block_signed = check_block_signature(signature_message, signatures_c);
    throw_unless(is_block_signed, err::unsigned_block);
    
    cell msg = build_message(
      sender_address,
      0,
      false,
      null(),
      begin_cell()
        .store_uint(op::check_block::success, 32)
        .store_uint(query_id, 64)
        .store_uint(root_hash, 256)
        .store_slice(in_msg_body)
      .end_cell()
    ).end_cell();
    send_raw_message(msg, send_mode::carry_remaining_value);
    return ();
  }

  throw(err::unknown_operation);
}

cell get_validators() method_id {
  load_globals();
  return g::validators;
}
