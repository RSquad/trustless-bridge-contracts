#include "../libs/stdlib.fc";
#include "../libs/ton_msg.lib.fc";
#include "../libs/errors.lib.fc";
#include "../libs/tvm.lib.fc";
#include "opcodes.fc";
#include "storage.fc";
#include "utils.fc";

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
  if ( in_msg_body.slice_empty?() ) { ;; accept simple transfer
    return ();
  }
  slice cs = in_msg_full.begin_parse();
  int flags = cs~load_uint(4);
  if ( flags & 1 ) { ;; ignore all bounced messages
    return ();
  }

  slice sender_address = cs~load_msg_addr();
  int op = in_msg_body~load_uint(32);
  int query_id = in_msg_body~load_uint(64);

  if ( op == op::new_key_block ) {
    ;; (slice cs, int special) = block.begin_parse_special();
    ;; cell test = cs~load_ref();
    cell block = in_msg_body~load_ref();
    int file_hash = in_msg_body~load_uint(256);
    int root_hash = cell_hash(block);
    cell signatures = in_msg_body~load_ref();

    ;; also checks if the block is keyblock
    slice custom_s = load_block_custom(block);

    slice signing_message = build_signing_message(root_hash, file_hash);
    load_globals();
    int block_signed? = check_block_signatures(signing_message, signatures);
    throw_unless(err::unsigned_block, block_signed?);

    (cell validators_list, int main) = load_validators_list(custom_s);
    ~dump(g::validators);
    update_validators_dict(validators_list, main);
    ~strdump("OPTIONAL UPDATE COMPLETED");
    ~dump(g::validators);
  
    cell msg = build_message(
      sender_address,
      0,
      false,
      null(),
      begin_cell()
        .store_uint(op::new_key_block::success, 32)
        .store_uint(query_id, 64)
        .store_uint(root_hash, 256)
        .store_slice(in_msg_body)
      .end_cell()
    ).end_cell();
    send_raw_message(msg, send_mode::carry_remaining_value);
    store_globals();
    return ();
  }

  if ( op == op::check_block ) {
    cell block = in_msg_body~load_ref();
    slice cs = block.begin_parse();
    int file_hash = in_msg_body~load_uint(256);
    int root_hash = cell_hash(block);
    cell signatures = in_msg_body~load_ref();

    throw_if(
      err::is_not_masterchain_block, 
      check_is_not_masterchain_block(cs~load_ref_slice())
    );
    slice signing_message = build_signing_message(root_hash, file_hash);
    load_globals();

    ;; if sign is correct, block in current epoch
    int block_signed? = check_block_signatures(signing_message, signatures);
    throw_unless(err::unsigned_block, block_signed?);
    
    cell msg = build_message(
      sender_address,
      0,
      false,
      null(),
      begin_cell()
        .store_uint(op::check_block::success, 32)
        .store_uint(query_id, 64)
        .store_uint(root_hash, 256)
        .store_slice(in_msg_body)
      .end_cell()
    ).end_cell();
    send_raw_message(msg, send_mode::carry_remaining_value);
    return ();
  }

  throw(err::unknown_operation);
}

cell get_validators() method_id {
  load_globals();
  return g::validators;
}

(cell, int, int) get_storage() method_id {
  load_globals();
  return (g::validators, g::total_weight, g::epoch_hash);
}
