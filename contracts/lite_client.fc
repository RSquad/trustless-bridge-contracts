#include "imports/stdlib.fc";

const int err::unknown_operation = 0xffff;

const int op::new_key_block = "op::new_key_block"c;
const int op::check_block = "op::check_block"c;
const int op::check_shard = "op::check_shard"c;

global cell  g::validators;
global int  g::root_hash;

() load_globals() impure {
  var ds = get_data().begin_parse();
  g::root_hash = ds~load_uint(256);
  g::validators = ds~load_ref();
  ds.end_parse();
}

() store_globals() impure {
  builder data = begin_cell();
  data.store_uint(g::root_hash, 256);
  data.store_ref(g::validators);
  set_data(data.end_cell());
}

() check_block_signature(int root_hash, cell signatures_c) impure {
  slice validators_list_slice = g::validators.begin_parse();
  ~dump(validators_list_slice.slice_bits()); ;; 169
  int val_type = validators_list_slice~load_uint(8); ;; 161
  ~dump(val_type);
  int utime_since = validators_list_slice~load_uint(32); ;; 129
  ~dump(utime_since);
  int utime_until = validators_list_slice~load_uint(32); ;; 97
  ~dump(utime_until);
  int total = validators_list_slice~load_uint(16); ;; 81
  ~dump(total);
  int main = validators_list_slice~load_uint(16); ;; 69
  ~dump(main);
  int weight = validators_list_slice~load_uint(64); ;; 5
  ~dump(weight);
  
  cell validators = validators_list_slice~load_dict();
  slice signatures_s = signatures_c.begin_parse();
  cell signatures = signatures_s~load_dict();

  int i = 0;
  (slice validator, int ok_val?) = validators.udict_get?(16, i);
  while (ok_val?) {

  
  int v_header = validator~load_uint(8);
  slice v_str_node_id = validator.preload_bits(32 + 256);
  int v_magic = validator~load_uint(32);
  throw_unless(v_magic == 0x8e81278a, err::unknown_operation);
  int v_pub = validator~load_uint(256);
  int v_weight = validator~load_uint(64);
  slice th = begin_cell()
    .store_uint(0xc6b41348, 32)
    .store_uint(v_pub, 256)
  .end_cell().begin_parse();
  int v_node_id = string_hash(th);

  int j = 0;
  (cell signature, int ok?) = signatures.udict_get_ref?(16, j);
  while (ok?) {
    slice sig_s = signature.begin_parse();
    int node_id_short = sig_s~load_uint(256);
    slice sig = sig_s~load_bits(512);
    ;; ~strdump("cheeek");
    ;; ~dump(node_id_short);
    ;; ~dump(v_node_id);
    if (node_id_short == v_node_id) {
      int is_signed = check_signature(root_hash, sig, v_pub);
      ;; ~dump(root_hash);
      ~dump(is_signed);
      ok? = 0;
    } else {
      j = j + 1;
      (signature, ok?) = signatures.udict_get_ref?(16, j);
    }
  }
  i = i + 1;
  (validator, ok_val?) = validators.udict_get?(16, i);
}

  return ();
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
  if ( in_msg_body.slice_empty?() ) { ;; accept simple transfer
    return ();
  }
  slice cs = in_msg_full.begin_parse();
  int flags = cs~load_uint(4);
  if ( flags & 1 ) { ;; ignore all bounced messages
    return ();
  }

  slice sender_address = cs~load_msg_addr();
  int op = in_msg_body~load_uint(32);
  int query_id = in_msg_body~load_uint(64);

  ;; new_key_block#11a78ffe query_id:uint64 block:^Cell signatures:^Cell = InternalMsgBody;
  ;; - checks that block in current epoch
  ;; - checks that block is keyblock
  ;; - checks that signatures are valid
  ;; - loads new epoch parameters (validators)
  ;; - update current epoch
  ;; - send to sender ok#ff8ff4e1 query_id:uint64 block_hash:uint256 = InternalMsgBody;
  ;; if something is wrong, reject
  if ( op == op::new_key_block ) {
    cell block = in_msg_body~load_ref();
    cell signatures_c = in_msg_body~load_ref();
    int root_hash = cell_hash(block);

    ~dump(root_hash);
    load_globals();
    ;; START SIG CHECK
    check_block_signature(root_hash, signatures_c);

    
    ;; END SIG CHECK
    
    ;; (slice cs, int special) = block.begin_parse_special();
    ;; cell test = cs~load_ref();
    

    slice cs = block.begin_parse();
    
    cell block_info = cs~load_ref();
    slice block_info_s = block_info.begin_parse();
    int block_type = block_info_s~load_uint(32);
    throw_unless(block_type == 0x9bc7a987, err::unknown_operation);
    ;; version, not_master, after_merge, before_split, after_split, want_split, want_merge
    block_info_s~load_uint(38);
    int key_block = block_info_s~load_uint(1);
    throw_unless(key_block,  err::unknown_operation);
    block_info_s~load_uint(1 + 8 + 32 + 32 );
    block_info_s~load_uint(8);
    ;; block_info_s~load

    cs~load_ref();
    cs~load_ref();
    cell extra = cs~load_ref();
    slice extra_s = extra.begin_parse();
    int tag = extra_s~load_uint(32);
    throw_unless(tag == 0x4a33f6fd, err::unknown_operation);
    extra_s~load_ref();
    extra_s~load_ref();
    extra_s~load_ref();
    cell custom = extra_s~load_ref();
    slice custom_s = custom.begin_parse();
    int custom_magic = custom_s~load_uint(16);
    throw_unless(custom_magic == 0xcca5, err::unknown_operation);
    int is_keyblock = custom_s~load_uint(1);
    throw_unless(is_keyblock, err::unknown_operation);
    custom_s~load_ref();
    custom_s~load_ref();
    custom_s~load_ref();
    cell config = custom_s~load_dict();
    (cell config_34, int flag?) = config.udict_get_ref?(32, 34);
    throw_unless(flag?, err::unknown_operation);
    g::validators = config_34;
    g::root_hash = root_hash;
    store_globals();
    ;; slice config_34_s = config_34.begin_parse();


    ;; int hash = cell_hash(block);
    ;; ~strdump("success");
    ;; ~dump(hash);
    ;; ~dump(block);

    ;; int is_keyblock = extra_s~load_uint(1);
    ;; ;; throw_unless(is_keyblock, "is not keyblock");

    
    ;; ;; TODO: parse config 34; store validators
    ;; ;; shard_hashes:ShardHashes
    ;; extra_s~load_ref();
    ;; ;; shard_fees:ShardFees
    ;; extra_s~load_ref();
    ;; ;; prev_blk_signatures
    ;; cell config_cell = extra_s~load_ref();
    ;; ;; if (~extra_s.slice_refs_empty?()) {
    ;; ;;   ;; config:key_block?ConfigParams
    ;; ;;   config_cell = extra_s~load_ref();
    ;; ;; }
    

    
    return ();
  }
  if ( op == op::check_block ) {
    return ();
  }
  if ( op == op::check_shard ) {
    return ();
  }

  throw(err::unknown_operation);
}

;; LiteClient


;; check_block#8eaa9d76 query_id:uint64 block:^Cell signatures:^Cell = InternalMsgBody;
;; - checks that block in current epoch
;; - correct sign
;; - send to sender correct#ce02b807 query_id:uint64 block_hash:uint256 = InternalMsgBody;

;; also todo: script to get data from liteservers and generate new_key_block msg

;; Transaction-checker
;; check proofs to confirm that a given transaction was committed in some masterchain block of the current epoch.
;; check_transaction#91d555f7 transaction:^Cell proof:^Cell current_block:^Cell = InternalMsgBody;
;; - respond transaction_checked#756adff1 transaction:^Cell = InternalMsgBody;
;; the format of proof and current_block are at participant discretion (current_block should contain proof for itself), 
;; transaction can be a pruned branch cell. Transaction-checker may also interact with Lite-client to check the validity of a given block.

;; also todo: Besides smart-contracts, 
;; solution should contain a script that gets data from lite-server and builds check_transaction message for any given transaction in Masterchain.

;; Solution
;; Solution should contain
;; 1. Code of Lite-client smart-contract and script for generation messages for that contract with build instructions.
;; 2. Code of Transaction-checker smart-contract and script for generation messages for that contract with build instructions.
;; 3. Addresses of smart-contracts deployed in Testnet and Fastnet respectively, with the tx_hash of transactions that demonstrate both successful and unsuccessful checks of blocks and transactions.

;; Scoring
;; 1. Correctness: the solution should correctly determine the validity of blocks and transactions.
;; 2. Gas usage
;; 3. The quality of the source code of your implementation of the smart contract (i.e., its readability and extensibility) will affect your final score.