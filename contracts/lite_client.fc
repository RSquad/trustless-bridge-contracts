#include "imports/stdlib.fc";
#include "lite_client/opcodes.fc";
#include "lite_client/errors.fc";
#include "lite_client/storage.fc";
#include "imports/ton_msg.lib.fc";


(int) check_block_signature(int root_hash, cell signatures_c, int file_hash) impure {
  (cell validators, int total_weight) = load_validators();
  slice signatures_s = signatures_c.begin_parse();
  cell signatures = signatures_s~load_dict();

  int signed_weight = 0;
  int i = 0;
  (slice validator, int ok_val?) = validators.udict_get?(16, i);
  while (ok_val?) {
      (int v_pub, int v_weight, int v_node_id) = parse_validator(validator);
  
    int j = 0;
      (cell signature, int ok?) = signatures.udict_get_ref?(16, j);
    while (ok?) {
      slice sig_s = signature.begin_parse();
      int node_id_short = sig_s~load_uint(256);
      slice sig = sig_s~load_bits(512);
      if (node_id_short == v_node_id) {
        slice sig_message = begin_cell()
      .store_uint(0x706e0bc5, 32)
      .store_uint(root_hash, 256)
      .store_uint(file_hash, 256)
      .end_cell().begin_parse();
        int is_signed = check_data_signature(sig_message, sig, v_pub);
        if (is_signed) {
          signed_weight = signed_weight + v_weight;
        }
        ok? = 0;
      } else {
        j = j + 1;
          (signature, ok?) = signatures.udict_get_ref?(16, j);
      }
    }
    i = i + 1;
      (validator, ok_val?) = validators.udict_get?(16, i);
  }

  return signed_weight * 3 >= 2 * total_weight;
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
  if ( in_msg_body.slice_empty?() ) { ;; accept simple transfer
    return ();
  }
  slice cs = in_msg_full.begin_parse();
  int flags = cs~load_uint(4);
  if ( flags & 1 ) { ;; ignore all bounced messages
    return ();
  }

  slice sender_address = cs~load_msg_addr();
  int op = in_msg_body~load_uint(32);
  int query_id = in_msg_body~load_uint(64);

  ;; new_key_block#11a78ffe query_id:uint64 block:^Cell signatures:^Cell = InternalMsgBody;
  ;; - checks that block in current epoch
  ;; - checks that block is keyblock
  ;; - checks that signatures are valid
  ;; - loads new epoch parameters (validators)
  ;; - update current epoch
  ;; - send to sender ok#ff8ff4e1 query_id:uint64 block_hash:uint256 = InternalMsgBody;
  ;; if something is wrong, reject
  if ( op == op::new_key_block ) {
    ;; (slice cs, int special) = block.begin_parse_special();
    ;; cell test = cs~load_ref();
    cell block = in_msg_body~load_ref();
    cell signatures_c = in_msg_body~load_ref();
    int file_hash = in_msg_body~load_uint(256);
    int root_hash = cell_hash(block);

    load_globals();
    
    


    slice cs = block.begin_parse();
    cell block_info = cs~load_ref();
    slice block_info_s = block_info.begin_parse();
    int block_type = block_info_s~load_uint(32);
    throw_unless(block_type == 0x9bc7a987, err::unknown_operation);
    ;; version, not_master, after_merge, before_split, after_split, want_split, want_merge
    block_info_s~load_uint(38);
    int key_block = block_info_s~load_uint(1);
    throw_unless(key_block,  err::unknown_operation);
    block_info_s~load_uint(1 + 8 + 32 + 32 );
    block_info_s~load_uint(8);
    ;; block_info_s~load

    cs~load_ref();
    cs~load_ref();
    cell extra = cs~load_ref();
    slice extra_s = extra.begin_parse();
    int tag = extra_s~load_uint(32);
    throw_unless(tag == 0x4a33f6fd, err::unknown_operation);
    extra_s~load_ref();
    extra_s~load_ref();
    extra_s~load_ref();
    cell custom = extra_s~load_ref();
    slice custom_s = custom.begin_parse();
    int custom_magic = custom_s~load_uint(16);
    throw_unless(custom_magic == 0xcca5, err::unknown_operation);
    int is_keyblock = custom_s~load_uint(1);
    throw_unless(is_keyblock, err::unknown_operation);
    custom_s~load_ref();
    custom_s~load_ref();
    custom_s~load_ref();
    cell config = custom_s~load_dict();
    (cell config_34, int flag?) = config.udict_get_ref?(32, 34);
    throw_unless(flag?, err::unknown_operation);

    int is_block_signed = check_block_signature(root_hash, signatures_c, file_hash);
    if (is_block_signed) {
      g::validators = config_34;
      g::root_hash = root_hash;
      store_globals();
    

      int query_id = 0;
      cell msg = build_message(
        sender_address,
        0,
        false,
        null(),
        begin_cell()
          .store_uint(op::new_key_block::success, 32)
          .store_uint(query_id, 64)
          .store_uint(root_hash, 256)
        .end_cell()
      ).end_cell();
      send_raw_message(msg, send_mode::carry_remaining_value);
      return ();
    }    
    return ();
  }
  if ( op == op::check_block ) {
    return ();
  }

  throw(err::unknown_operation);
}

;; LiteClient


;; check_block#8eaa9d76 query_id:uint64 block:^Cell signatures:^Cell = InternalMsgBody;
;; - checks that block in current epoch
;; - correct sign
;; - send to sender correct#ce02b807 query_id:uint64 block_hash:uint256 = InternalMsgBody;

;; also todo: script to get data from liteservers and generate new_key_block msg

;; Transaction-checker
;; check proofs to confirm that a given transaction was committed in some masterchain block of the current epoch.
;; check_transaction#91d555f7 transaction:^Cell proof:^Cell current_block:^Cell = InternalMsgBody;
;; - respond transaction_checked#756adff1 transaction:^Cell = InternalMsgBody;
;; the format of proof and current_block are at participant discretion (current_block should contain proof for itself), 
;; transaction can be a pruned branch cell. Transaction-checker may also interact with Lite-client to check the validity of a given block.

;; also todo: Besides smart-contracts, 
;; solution should contain a script that gets data from lite-server and builds check_transaction message for any given transaction in Masterchain.

;; Solution
;; Solution should contain
;; 1. Code of Lite-client smart-contract and script for generation messages for that contract with build instructions.
;; 2. Code of Transaction-checker smart-contract and script for generation messages for that contract with build instructions.
;; 3. Addresses of smart-contracts deployed in Testnet and Fastnet respectively, with the tx_hash of transactions that demonstrate both successful and unsuccessful checks of blocks and transactions.

;; Scoring
;; 1. Correctness: the solution should correctly determine the validity of blocks and transactions.
;; 2. Gas usage
;; 3. The quality of the source code of your implementation of the smart contract (i.e., its readability and extensibility) will affect your final score.